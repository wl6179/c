遇到算法
============================

递归
----------

自我调用，数学上确实有很多概念是用到自己调用自己的定义，这就是递归。

  - 关键：需要定义一个**基础条件**（Base Case）

    即*终止条件*；

    否则递归将会没完没了的死循环；

    ```c
    0! = 1
    ```

    并且

    ```c
    1! = 1        // （1 * 0!） = 1 * 1
    ```

  - 典型例子，无疑是阶乘

    **方法解析**：

      1.先把*基础条件*写上，定好框架

      `````c
      int factorial(int n)
      {
        // Base Case.
        if (n == 0)
        {
          return 1;
        }
      }
      `````

      2.如果*参数*n不是0时，应该返回什么（返回一个有规律的表达式）

      那么，应该返回

      ```c
      return (n * factorial(n-1));
      ```

    **完整代码**：

      `````c
      int factorial(int n)
      {
        // Base Case.基础条件（可以停止的终点条件，不再递归！）
        if (n == 0)
        {
          return 1;
        }
        // Other Case.规律公式（可以一直循环下去的公式！）
        else
        {
          return n * factorial(n-1);    // 递推关系
        }
      }
      `````

    **数据结构**：

      这种递归创造出来的*数据结构*，属于**堆栈**，Why？

        - 层层展开，然后层层收回；【有 先进后出 特征】

        - 在读取某一层时，无法读取更内层的 参数和局部变量！

          例如

          当调用 factorial(1)，即它在最外层时，只能读取它的参数2、和它的局部变量；但是它此时，是无法读取访问 factorial(3) 参数3～甚至是更上层的 main() 步骤的函数的 内部和其局部变量！

        - 栈顶

          当读取到 factorial(0) 时，就是‘栈顶’；（某个*位置*）

        - 栈帧   Stack Frame

          每个层的函数调用，之*存储空间*（即参数和局部变量的）；

      OS 操作系统在每一个程序运行时，会为其预留一块**栈空间**。在程序的函数各种调用时，就直接在这个栈空间里分配*栈帧*，函数`返回`时就立刻释放*栈帧*。

      万一，你忘了写 Base Case，就会导致OS分配给你的栈空间，因无限执行被耗尽。

    **数学归纳法** ×

      如何从数学的角度证明 函数 factorial(n) 的正确性？

      可以使用数学的`数学归纳法`，即证明下一层（级）函数的正确，就证明自己也是正确的。

      例如

        factorial(n) 的正确，只需要证明 factorial(n-1) 正确；

        factorial(n-1) 的正确，只需要证明 factorial(n-2) 正确；

        ……

        factorial(n-x) 的正确，最终只需要证明 `Base Case` 的 factorial(0) 正确即可；

          - 那么，最终证明 `return 1;` 完全符合阶乘的规则，是正确的！ 如此往回反推，全都正确。这就是`数学归纳法`。

  - **最后注意**

    递归，与*循环*是完全等价的。

    同时，*递归*也是 *计算机* 的精髓，也是 *编程语言* 的精髓所在。

    举两个语法的例子：

      1.表达式

      表达式就是递归定义的。

      **表达式** ---> 表达式（参数列表）

      参数列表 ---> 表达式，表达式，**表达式**

      2.语句

      **语句** <---> if(控制表达式) **语句**

      或

      **语句** <---> while(控制表达式) **语句**

      等等

写到这里，可以来一条华丽的分割线了。
***
克里斯王


迭代
----------

每次都有一点区别的*重复*工作，就是迭代。

  - 迭代可以用**递归**来做：

    ```例如同上的 n!```

  - 迭代也可以用**循环**来做：

    ```c
    /* 例如，也用循环做一遍 n! */

    int factorial(int n)
    {
      int result = 1;       // 初值，就相当于递归的 Base Case 结束条件.

      while (n>0) {
        result = (result * n);      // 相当于递归的 递推关系.
        n = n - 1;
      }

      return result;
    }
    ```
