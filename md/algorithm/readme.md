遇到算法
============================

递归
----------

自我调用，数学上确实有很多概念是用到自己调用自己的定义，这就是递归。

  - 关键：需要定义一个**基础条件**（Base Case）

    即*终止条件*；

    否则递归将会没完没了的死循环；

    ```c
    0! = 1
    ```

    并且

    ```c
    1! = 1        // （1 * 0!） = 1 * 1
    ```

  - 典型例子，无疑是阶乘

    方法解析：

      1.先把*基础条件*写上，定好框架

      `````c
      int factorial(int n)
      {
        // Base Case.
        if (n == 0)
        {
          return 1;
        }
      }
      `````

      2.如果*参数*n不是0时，应该返回什么（返回一个有规律的表达式）

      那么，应该返回

      ```c
      return (n * factorial(n-1));
      ```

    完整代码：

      `````c
      int factorial(int n)
      {
        // Base Case.基础条件（可以停止的终点条件，不再递归！）
        if (n == 0)
        {
          return 1;
        }
        // Other Case.规律公式（可以一直循环下去的公式！）
        else
        {
          return n * factorial(n-1);    // （数学）公式
        }
      }
      `````

    *数据结构*：

      这种递归创造出来的*数据结构*，属于**堆栈**，Why？

        - 层层展开，然后层层收回；【有 先进后出 特征】

        - 在读取某一层时，无法读取更内层的 参数和局部变量！

          例如

          当调用 factorial(1)，即它在最外层时，只能读取它的参数2、和它的局部变量；但是它此时，是无法读取访问 factorial(3) 参数3～甚至是更上层的 main() 步骤的函数的 内部和其局部变量！

        - 栈顶

          当读取到 factorial(0) 时，就是‘栈顶’；（某个*位置*）

        - 栈帧   Stack Frame

          每个层的函数调用，之*存储空间*（即参数和局部变量的）；

      OS 操作系统在每一个程序运行时，会为其预留一块**栈空间**。在程序的函数各种调用时，就直接在这个栈空间里分配*栈帧*，函数返回时就立刻释放*栈帧*。
