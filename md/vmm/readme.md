[返回目录](/README.md)

虚拟内存管理
===========================

虚拟内存管理起到的作用有：

  虚拟内存管理，可以`控制`物理内存的`访问权限`；

  ```
  利用 CPU 模式和 MMU 的内存保护机制实现，内核地址空间也被保护起来，防止在用户模式下执行错误的指令意外改写内核数据。这样，`恶意代码`的破坏能力受到了限制。
  ```

  虚拟内存管理，可以让每个进程有`独立的地址空间`；

  ```
  不同进程中的同一个VA被MMU映射到不同的PA，并且在某一个进程中访问任何地址都不可能访问到另外一个进程的数据。这样，`恶意代码`无法访问另一个进程任何数据。

  每个进程，都认为自己独占`整个虚拟地址空间`，这样链接器和加载器的实现会比较容易，不必考虑各进程的地址范围是否冲突。
  ```


- 用 ps 命令查看当前终端下的`进程`：

```bash
ps
```

```vim
  PID TTY          TIME CMD
 8543 pts/4    00:00:00 bash        # bash 进程的 id
31520 pts/4    00:00:00 ps
```

- 查看此 **bash 进程**的`虚拟地址空间`：

  `/proc 目录`中的文件，是由内核虚拟出来的文件系统。当前系统中运行的每个`进程`在 /proc 下都有一个`子目录`，目录名就是进程的id。查看目录下的文件可以得到该进程的相关信息。

  例如，查看 maps：

```bash
cat /proc/8543/maps
```

```vim
00400000-004f4000 r-xp 00000000 fd:00 4849671                            /bin/bash
006f3000-006f4000 r--p 000f3000 fd:00 4849671                            /bin/bash
006f4000-006fd000 rw-p 000f4000 fd:00 4849671                            /bin/bash
006fd000-00703000 rw-p 00000000 00:00 0
016d3000-018b7000 rw-p 00000000 00:00 0                                  [heap]
...
7f1ecc02a000-7f1ecc02b000 rw-p 0000b000 fd:00 11407931                   /lib/x86_64-linux-gnu/libnss_files-2.23.so
7f1ecc02b000-7f1ecc031000 rw-p 00000000 00:00 0
7f1ecc031000-7f1ecc03c000 r-xp 00000000 fd:00 11407941                   /lib/x86_64-linux-gnu/libnss_nis-2.23.so
...
7f1ecda3b000-7f1ecda3c000 rw-p 00026000 fd:00 11407804                   /lib/x86_64-linux-gnu/ld-2.23.so
7f1ecda3c000-7f1ecda3d000 rw-p 00000000 00:00 0
7ffe0ded1000-7ffe0def2000 rw-p 00000000 00:00 0                          [stack]
7ffe0dff7000-7ffe0dff9000 r--p 00000000 00:00 0                          [vvar]
7ffe0dff9000-7ffe0dffb000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
```

  或者：

```bash
pmap 8543
```

```vim
8543:   bash
0000000000400000    976K r-x-- bash
00000000006f3000      4K r---- bash
00000000006f4000     36K rw--- bash
00000000006fd000     24K rw---   [ anon ]
00000000016d3000   1952K rw---   [ anon ]
00007f1ecbe1f000     44K r-x-- libnss_files-2.23.so
...
00007f1ecd814000      4K rw--- libtinfo.so.5.9
00007f1ecd815000    152K r-x-- ld-2.23.so
00007f1ecd9ff000    100K r---- bash.mo
00007f1ecda18000     16K rw---   [ anon ]
00007f1ecda31000     28K r--s- gconv-modules.cache
00007f1ecda38000      8K rw---   [ anon ]
00007f1ecda3a000      4K r---- ld-2.23.so
00007f1ecda3b000      4K rw--- ld-2.23.so
00007f1ecda3c000      4K rw---   [ anon ]
00007ffe0ded1000    132K rw---   [ stack ]
00007ffe0dff7000      8K r----   [ anon ]
00007ffe0dff9000      8K r-x--   [ anon ]
ffffffffff600000      4K r-x--   [ anon ]
 total            30044K
```

- 运行多个 bash 程序（进程）时，查看对比一下他们的（虚拟）`地址空间`：

  多个 bash 进程，都占用同样的`地址空间`。因这些地址是在`编译链接`时写进 /bin/bash 可执行文件的，所以这两个进程都加载它，地址空间自然也一样。那么，是不是他们都占用了同样的内存地址？会导致冲突？

    ```
    当然不会。就是因为虚拟内存管理 VA 的机制。

    这两个进程在同一个系统 Ubuntu 中同时运行着，它们的 Data Segment 占用相同的 VA。但是两个进程互不相干。显然 Data Segment 中保存的数据应该是不同的。

    相同的 VA 怎么会有不同的`数据`呢？因为它们已被映射到不同的 PA（Physical Address，计算机体系结构的 虚拟内存管理机制，需要 CPU 能支持 MMU 内存管理单元）。
    ```

- 另外，注意到两个进程，都使用的同一个共享库时：

    加载地址并不完全相同。可以做到 只读的部分是共享的，可读可写的部分不共享。因此使用`共享库`将可以大大节省`内存`。

    如 libc，系统中几乎所有的进程都映射 libc 到自己的进程地址空间，而 libc 的只读部分在物理内存中`只需要存在一份`，就可以被所有进程共享，这就是“共享库”名称的由来。

- 分配连续内存地址的原理：（物理内存一般没有那么多连续地址，考的就是 VA 机制映射起来！）

  VA 到 PA 的映射会给分配和释放内存带来方便，物理地址不连续的几块内存，可以映射成`虚拟地址连续`的一块内存。

  比如

    用 malloc 分配一块很大的内存空间，虽然有足够多的空闲`物理内存`，却没有足够大的连续`空闲内存`，这时就可以分配多个不连续的物理页面，而映射到`一个`连续的`虚拟地址范围`。

- 最后一点最牛：

  `虚拟内存`，可以当你`物理内存`不足时，映射到`硬盘`！！令各`进程`仍然能够正常运行。

  Swap 交换设备：

    在磁盘上临时保存虚拟内存页面的可能是一个`磁盘分区`，也可能是一个`磁盘文件`，称为交换设备（Swap Device）。

  换页操作：

    Swap 的交换过程，换出和换入操作统，称为换页。

    **换出：**

      将物理页面中的数据保存到磁盘，并`解除地址映射`释放物理页面 PA。

    **换入：**

      从空闲物理页面中分配一个 PA 并`建立（新）地址映射`。然后将磁盘暂存的页面（重新）加载回此‘内存 VA’，
